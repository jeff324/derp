% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sample_wrapper.R
\name{run_mcmc}
\alias{run_mcmc}
\title{Posterior sampling using differential evolution}
\usage{
run_mcmc(model, pars = NULL, data, sampler = "de", num_samples = NULL,
  num_chains = NULL, migration_start = NULL, migration_end = NULL,
  migration_freq = NULL, migrate_subject_only = FALSE,
  randomize_phi = TRUE, update = 100, init_theta = NULL,
  init_phi = NULL, return_as_mcmc = TRUE, parallel_backend = "none",
  n_cores = NULL, benchmark = FALSE)
}
\arguments{
\item{model}{A \code{function}. Defines a Bayesian model. See example below.}

\item{pars}{A \code{list}. Specifies the names of parameters along with their initialization bounds and blocks. See example below.}

\item{data}{A \code{list}. Specifies the data to be modeled. See example.}

\item{sampler}{A \code{character}. Specifies the name of the sampler to be used. \code{de} is the only built-in sampler.}

\item{num_samples}{A \code{numeric}. The total number of samples to collect.}

\item{num_chains}{A \code{numeric}. The number of chains to run.}

\item{migration_start}{A \code{numeric}. Iteration to start migrating. This should be after chains are burned in. If \code{NULL}, migration is not done.}

\item{migration_end}{A \code{numeric}. Iteration to stop migrating. Migration should stop well before sampling is finished. If \code{NULL}, migration is not done.}

\item{migration_freq}{A \code{numeric}. Number of iterations to wait between each migration step. If \code{NULL}, migration is not done.}

\item{migrate_subject_only}{A \code{logical}. If \code{TRUE}, migration only performed on subject-level parameters. Otherwise, migration is performed on all parameters.}

\item{randomize_phi}{A \code{logical}. Should the correlational structure between level-1 and level-2 parameters be ignored.}

\item{update}{A \code{numeric}. Specifies the number of iterations before printing the current iteration number to the console.}

\item{init_theta}{A list where each element contains a named vector of parameter initial start values for each subject.}

\item{init_phi}{A named vector parameter initial start values}

\item{parallel_backend}{A character vector either 'MPI', 'doParallel', or 'none' indicating backend for parallelization. Default is none.}

\item{n_cores}{A \code{numeric}. Number of cores when parallel_backend is specified.}

\item{benchmark}{A \code{logical}. Produces compute times benchmark purposes.
Oftentimes, ignoring this correlation will lead to better sampling.}
}
\description{
\code{powder} Runs power posterior sampling using differential evolution markov chain monte carlo
}
\examples{
\dontrun{
library(derp)
#### Simulate data
data = list(response = rnorm(100,2,1))
#### Model parameters
pars = list(
'mu' =    list('init'=c(1,10)),
'sd' =    list('init'=c(.1,5))
)
#### Define model
model = function() {
    normal_lpdf(mu, 0, 3)
    gamma_lpdf(sd, 1, 1)
    normal_lpdf(response, mu, sd)
}
#### Run the sampler
samples = run_mcmc(model, pars, data,
                  migration_start = 500, migration_end = 700,
                  migration_freq = 10, num_samples=3000)
mcmc_snip = snip(samples,burnin=1000,thin=1)
summary(mcmc_snip)
}
}
